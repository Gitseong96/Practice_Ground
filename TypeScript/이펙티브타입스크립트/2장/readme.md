# 타입스크립트의 타입 시스템
- 타입스크립트는 코드를 다바스크립트로 변환하는 역활도 하지만, 가장 중요한 역활은 타입 시스템에 있다.
    - 타입스크립트를 사용하는 진정한 이유

## 편집기를 사용하여 타입 시스템 탐색하기 
기능
- 타입스크립트 컴파일러 (tsc)
- 단독으로 실행할 수 있는 타입스크립트 서버 (TsSever)

* 
    * 편지기에서 타입스크립트 언어 서비스를 적그 활용해야 한다.
    * 편지기를 사용하면 어떻게 타입 시스템이 동작하는지 , 그리고 타입스크립가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.
    * 타입스크립트가 동작을 어떻게 모델링하는지 알기 위해 타입 서넝 파일을 찾아보는 방법을 터득해야합니다.

## 타입의 값들의 집합이라고 생각하기
- 런타임에 모든 변수는 자바스크립트 세상의 값으로부터 정해지는 각자의 고유한 값을 가진다.
- 가장 작은 집합은 아무 값도 포함하지 않는 공집합이며 , 타입스크립트에서는 never 타입이다.
    - never 타입으로 선언된 변수는 아무런 값도 할당할 수 없다.
- 다음으로 작은 집합은 한가지 값만 포함하는 타입
    - 유닛(unit) 타입 이라고 불리는 리터럴(literal) 타입이다.
- 두 개 혹은 세 개로 묶으려면 유니온(union) 타입을 사용
* 
    * 타입을 값의 집합으로 생각하면 이해하기 쳔하다,
    * 타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합으로 표현된다.
    * 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그타입에 속할 수 있다.

* keyof : 객체 형태의 타입을, 따로 속성들만 뽑아 유니온 타입으로 만들어주는 연산자

## 타입 공간과 값 공간의 심벌 구분하기  
- 타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.
- 심벌은 이름이 같더라도 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있다.
```
    type T = number
    const T = 5
    => TSC const T = 5
    컴파일러시 타입 값은 사라지기 때문에 상수만 노출된다.
```
* 값에서는 & 와 |는 AND와 OR 이고 , 타입에서는 인터섹션과 유니온이다.
* const는 새 변수를 선언하지만 ,as const 리터럴 또는 리터럴 포현식의 추론된 타입을 바꾼다.

* 
    * 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득해야한다.
    * 모든 값은 타입을 가지지만 , 타입은 값을 가지지 않는다.
    * type 과 interface 같은 키워드는 타입 공간에만 존재한다.
    * class나 enum 같은 키워드는 타입과 값 두가지로 사용될 수 있다.
    * typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.

## 타입 단언보다는 타입 선언을 사용하기
타입을 부여하는 방법 2가지
```
    interface Person{name :string};
    
    const giseong : Person = {name:"giseong"}; : 타입 선언
    const jang = {name : "Jang"} as Person; : 타입 단언
```
* 타입 단언은 강제로 타입을 지정했기 때문에 타입 체커에게 오류를 무시하라 명령하는 것과 같다.
* 타입 단언은 타입체커가 추론한 타입보다 사용자가 판단하는 타입이 더 정확할 때 의미가 있다.
* DOM을 사용할때는 타입스크립트가 DOM에 접근할 수 없기 때문에 엘리먼트의 값을 알지 못하기 때문에 사용

* 타입 단언 보다 타입 선언을 사용해야 한다.
* 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 한다.
* 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서는 타입 단언문과 null 아님 단언문을 사용하면 된다.


## 잉여 속성 체크의 한계
* 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행된다.
* 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역활이 다르다.
* 잉여 속성 체크에는 한계가 있고, 임시 변수를 도입하면 잉여속성 체크를 건너뛸 수 있다는 점을 기억해야 한다.