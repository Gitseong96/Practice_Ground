# 타입스크립트의 타입 시스템
- 타입스크립트는 코드를 다바스크립트로 변환하는 역활도 하지만, 가장 중요한 역활은 타입 시스템에 있다.
    - 타입스크립트를 사용하는 진정한 이유

## 편집기를 사용하여 타입 시스템 탐색하기 
기능
- 타입스크립트 컴파일러 (tsc)
- 단독으로 실행할 수 있는 타입스크립트 서버 (TsSever)

* 
    * 편지기에서 타입스크립트 언어 서비스를 적그 활용해야 한다.
    * 편지기를 사용하면 어떻게 타입 시스템이 동작하는지 , 그리고 타입스크립가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.
    * 타입스크립트가 동작을 어떻게 모델링하는지 알기 위해 타입 서넝 파일을 찾아보는 방법을 터득해야합니다.

## 타입의 값들의 집합이라고 생각하기
- 런타임에 모든 변수는 자바스크립트 세상의 값으로부터 정해지는 각자의 고유한 값을 가진다.
- 가장 작은 집합은 아무 값도 포함하지 않는 공집합이며 , 타입스크립트에서는 never 타입이다.
    - never 타입으로 선언된 변수는 아무런 값도 할당할 수 없다.
- 다음으로 작은 집합은 한가지 값만 포함하는 타입
    - 유닛(unit) 타입 이라고 불리는 리터럴(literal) 타입이다.
- 두 개 혹은 세 개로 묶으려면 유니온(union) 타입을 사용
* 
    * 타입을 값의 집합으로 생각하면 이해하기 쳔하다,
    * 타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합으로 표현된다.
    * 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그타입에 속할 수 있다.

* keyof : 객체 형태의 타입을, 따로 속성들만 뽑아 유니온 타입으로 만들어주는 연산자

## 타입 공간과 값 공간의 심벌 구분하기  
- 타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.
- 심벌은 이름이 같더라도 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있다.
```
    type T = number
    const T = 5
    => TSC const T = 5
    컴파일러시 타입 값은 사라지기 때문에 상수만 노출된다.
```
* 값에서는 & 와 |는 AND와 OR 이고 , 타입에서는 인터섹션과 유니온이다.
* const는 새 변수를 선언하지만 ,as const 리터럴 또는 리터럴 포현식의 추론된 타입을 바꾼다.

* 
    * 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득해야한다.
    * 모든 값은 타입을 가지지만 , 타입은 값을 가지지 않는다.
    * type 과 interface 같은 키워드는 타입 공간에만 존재한다.
    * class나 enum 같은 키워드는 타입과 값 두가지로 사용될 수 있다.
    * typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.

## 타입 단언보다는 타입 선언을 사용하기
타입을 부여하는 방법 2가지
```
    interface Person{name :string};
    
    const giseong : Person = {name:"giseong"}; : 타입 선언
    const jang = {name : "Jang"} as Person; : 타입 단언
```
* 타입 단언은 강제로 타입을 지정했기 때문에 타입 체커에게 오류를 무시하라 명령하는 것과 같다.
* 타입 단언은 타입체커가 추론한 타입보다 사용자가 판단하는 타입이 더 정확할 때 의미가 있다.
* DOM을 사용할때는 타입스크립트가 DOM에 접근할 수 없기 때문에 엘리먼트의 값을 알지 못하기 때문에 사용

* 타입 단언 보다 타입 선언을 사용해야 한다.
* 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 한다.
* 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서는 타입 단언문과 null 아님 단언문을 사용하면 된다.


## 잉여 속성 체크의 한계
* 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행된다.
* 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역활이 다르다.
* 잉여 속성 체크에는 한계가 있고, 임시 변수를 도입하면 잉여속성 체크를 건너뛸 수 있다는 점을 기억해야 한다.

## 함수 표현식에 타입 적용
* 자바스크립트에서는 함수 문장식과 표현식을 다르게 인식한다.
* 매개변수나 반환 값에 타입을 명시하기보다는 함수 표현식 전체에 타입 구문을 적용하는 것이 좋다.
* 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 부니해 내거나 이미 존재하는 타입을 찾아보자
* 라이브러리를 직접 만든다면 공통 콜백에 타입을 제공해야 한다,
* 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.

## 타입과 인터페이스의 차이점
* 타입스크립트에서 named type을 정의하는 방법은 두가지가 있다.
    * type
    * interface
* 비슷한점
    * 상태에는 차이가 없다.
    * 인덱스 시그니처에 interface와 type 둘다 사용가능
    * 함수 타입에도 interface 와 type 둘다 사용가능
    * 제네릭 타입에도 interface와 type 둘다 사용가능
    * interface와 type 둘다 서로 확장 가능
        * interface는 유니온 타입 같은 복잡한 타입을 확장하지 못한다. : 확장하고 싶다면 타입과 & 를 사용해야 한다.

* 다른점
    * 인터페이스는 타입을 확장할 수 있지만, 유니온 타입은 할 수 없다.
    * type 키워드는 유니온이 될 수도 있고 , 매핑된 타입 또는 조건부 타입 같은 고급 기능에 활용되기도 한다.
    * 튜플과 배열 타입도 type키워드를 이용해 더 간결하게 표현할 수 있다.
    * interface 는 보강이 가능하다.(augment, 선언 보강)
    ```
        interface AA{
            name:string;
        }
        interface AA{
            age:number;
        }

        const Data : AA ={
            name : "JangGiesong",
            age : 28
        }
    ```

* 복잡한 타입이라면 type 을 추천
* 두 가지다 사용이 가능하다면 한 가지 방법으로 일관성 있게 작성
* API에 대한 타입 선언을 작성해야한다면 인터페이스를 이용해 작성을 추천
    * API가 변경될 때 사용자가 인터페이스를 통해 새로운 필드를 병합할 수 있기 때문에



